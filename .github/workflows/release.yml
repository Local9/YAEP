name: Build and Release

on:
  workflow_dispatch:

env:
  DOTNET_VERSION: '9.0.x'

jobs:
  prepare-release:
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      pull-requests: read
    outputs:
      version: ${{ steps.increment_version.outputs.version }}
      has_changes: ${{ steps.get_last_tag.outputs.has_changes }}
      last_tag: ${{ env.LAST_TAG }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}

      - name: Get current version
        id: get_version
        run: |
          $version = Select-String -Path "YAEP.AvaloniaUI\YAEP.AvaloniaUI.csproj" -Pattern '<Version>(\d+)\.(\d+)\.(\d+)</Version>' | ForEach-Object { $_.Matches.Groups[1..3].Value -join '.' }
          if ([string]::IsNullOrEmpty($version)) {
            $version = "1.0.0"
          }
          Write-Host "Current version: $version"
          echo "CURRENT_VERSION=$version" >> $env:GITHUB_ENV
          $parts = $version -split '\.'
          echo "MAJOR=$($parts[0])" >> $env:GITHUB_ENV
          echo "MINOR=$($parts[1])" >> $env:GITHUB_ENV
          echo "PATCH=$($parts[2])" >> $env:GITHUB_ENV

      - name: Get last tag
        id: get_last_tag
        run: |
          $ErrorActionPreference = "Continue"
          $lastTag = ""
          $hasChanges = "false"
          
          # Fetch all tags to ensure we have them
          Write-Host "Fetching all tags..."
          git fetch --tags --force
          
          # Get the most recent tag (sorted by version), won't fail if no tags exist
          $tagOutput = git tag --sort=-version:refname | Select-Object -First 1
          if (-not [string]::IsNullOrWhiteSpace($tagOutput)) {
            $lastTag = $tagOutput.Trim()
            Write-Host "Found last tag: $lastTag"
            
            # Get the commit SHA that the tag points to (handles both annotated and lightweight tags)
            $tagCommit = git rev-parse "$lastTag^{commit}" 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host "Warning: Could not resolve tag commit: $tagCommit"
              Write-Host "Assuming changes exist for safety"
              $hasChanges = "true"
            } else {
              $tagCommit = $tagCommit.Trim()
              Write-Host "Tag $lastTag points to commit: $tagCommit"
              
              # Get current HEAD commit
              $headCommit = git rev-parse HEAD 2>&1
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Warning: Could not get HEAD commit"
                Write-Host "Assuming changes exist for safety"
                $hasChanges = "true"
              } else {
                $headCommit = $headCommit.Trim()
                Write-Host "Current HEAD commit: $headCommit"
                
                # Check if there are commits between tag and HEAD
                # Use ^{commit} to dereference annotated tags to their commit
                Write-Host "Checking for commits between $lastTag and HEAD..."
                $commitCountOutput = git rev-list "$lastTag^{commit}..HEAD" --count 2>&1
                
                if ($LASTEXITCODE -eq 0) {
                  if (-not [string]::IsNullOrWhiteSpace($commitCountOutput)) {
                    $commitCount = [int]$commitCountOutput.Trim()
                    Write-Host "Commit count: $commitCount"
                    if ($commitCount -gt 0) {
                      $hasChanges = "true"
                      Write-Host "Found $commitCount new commits since last tag"
                    } else {
                      Write-Host "No new commits since last tag, skipping version bump and release"
                    }
                  } else {
                    Write-Host "No commit count output, checking if commits exist..."
                    # Fallback: check if there are any commits at all
                    $commitList = git rev-list "$lastTag^{commit}..HEAD" 2>&1
                    if (-not [string]::IsNullOrWhiteSpace($commitList)) {
                      $hasChanges = "true"
                      Write-Host "Found commits between tag and HEAD"
                    } else {
                      Write-Host "No new commits since last tag, skipping version bump and release"
                    }
                  }
                } else {
                  Write-Host "Warning: git rev-list failed with exit code $LASTEXITCODE"
                  Write-Host "Output: $commitCountOutput"
                  Write-Host "Assuming changes exist for safety"
                  $hasChanges = "true"
                }
              }
            }
          } else {
            Write-Host "No existing tags found - this will be the first release"
            $hasChanges = "true"
          }
          
          Write-Host "Last tag: $lastTag (empty if none)"
          Write-Host "Has changes: $hasChanges"
          echo "has_changes=$hasChanges" >> $env:GITHUB_OUTPUT
          echo "LAST_TAG=$lastTag" >> $env:GITHUB_ENV

      - name: Increment version
        id: increment_version
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $patch = [int]$env:PATCH + 1
          $newVersion = "$env:MAJOR.$env:MINOR.$patch"
          Write-Host "New version: $newVersion"
          echo "version=$newVersion" >> $env:GITHUB_OUTPUT

      - name: Update version in project files
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $newVersion = "${{ steps.increment_version.outputs.version }}"
          $assemblyVersion = "$newVersion.0"
          $files = @("YAEP.AvaloniaUI\YAEP.AvaloniaUI.csproj", "YAEP.Interop\YAEP.Interop.csproj", "YAEP.Interop.Windows\YAEP.Interop.Windows.csproj", "YAEP.Interop.Linux\YAEP.Interop.Linux.csproj", "YAEP.Shared\YAEP.Shared.csproj")
          
          function Update-VersionProperty {
            param($content, $propertyName, $value, $insertAfterPattern)
            if ($content -match "<$propertyName>([^<]+)</$propertyName>") {
              $content -replace "<$propertyName>([^<]+)</$propertyName>", "<$propertyName>$value</$propertyName>"
            } else {
              $content -replace "($insertAfterPattern)", "`$1`n    <$propertyName>$value</$propertyName>"
            }
          }
          
          foreach ($file in $files) {
            if (Test-Path $file) {
              $content = Get-Content $file -Raw
              $content = Update-VersionProperty $content "Version" $newVersion '(<TargetFramework>.*?</TargetFramework>)'
              $content = Update-VersionProperty $content "AssemblyVersion" $assemblyVersion '(<Version>.*?</Version>)'
              $content = Update-VersionProperty $content "FileVersion" $assemblyVersion '(<AssemblyVersion>.*?</AssemblyVersion>)'
              
              if ($file -like "*YAEP.AvaloniaUI*") {
                if (-not ($content -match '<AssemblyName>')) {
                  $content = $content -replace '(<FileVersion>.*?</FileVersion>)', "`$1`n    <AssemblyName>YAEP</AssemblyName>"
                } else {
                  $content = $content -replace '<AssemblyName>.*?</AssemblyName>', "<AssemblyName>YAEP</AssemblyName>"
                }
              }
              Set-Content $file -Value $content -NoNewline
            }
          }

      - name: Configure Git
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version bump
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git add YAEP.AvaloniaUI/YAEP.AvaloniaUI.csproj YAEP.Interop/YAEP.Interop.csproj YAEP.Interop.Windows/YAEP.Interop.Windows.csproj YAEP.Interop.Linux/YAEP.Interop.Linux.csproj YAEP.Shared/YAEP.Shared.csproj
          git commit -m "Bump version to ${{ steps.increment_version.outputs.version }}" || exit 0

      - name: Push version bump commit
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git push origin main

      - name: Create git tag
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $version = "${{ steps.increment_version.outputs.version }}"
          git tag -a "v$version" -m "Release v$version"
          git push origin "v$version"

  build:
    needs: prepare-release
    if: needs.prepare-release.outputs.has_changes == 'true'
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        include:
          - os: windows-latest
            runtime: win-x64
            package_ext: zip
          - os: ubuntu-latest
            runtime: linux-x64
            package_ext: tar.gz
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
    env:
      VERSION: ${{ needs.prepare-release.outputs.version }}
      PACKAGE_NAME: YAEP-v${{ needs.prepare-release.outputs.version }}-${{ matrix.runtime }}.${{ matrix.package_ext }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore YAEP.sln

      - name: Build solution
        run: dotnet build YAEP.AvaloniaUI/YAEP.AvaloniaUI.csproj --configuration Release --runtime ${{ matrix.runtime }} --no-restore

      - name: Publish application
        run: dotnet publish YAEP.AvaloniaUI/YAEP.AvaloniaUI.csproj --configuration Release --runtime ${{ matrix.runtime }} --output ./publish --no-build

      - name: Create release package (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Compress-Archive -Path ./publish/* -DestinationPath "${{ env.PACKAGE_NAME }}" -Force
          Write-Host "Created package: ${{ env.PACKAGE_NAME }}"
          echo "package_name=${{ env.PACKAGE_NAME }}" >> $env:GITHUB_OUTPUT

      - name: Create release package (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          cd publish
          tar -czf "../${{ env.PACKAGE_NAME }}" *
          cd ..
          echo "package_name=${{ env.PACKAGE_NAME }}" >> $GITHUB_OUTPUT
          echo "Created package: ${{ env.PACKAGE_NAME }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: package-${{ matrix.runtime }}
          path: ${{ env.PACKAGE_NAME }}
          retention-days: 7

  create-release:
    needs: [prepare-release, build]
    if: needs.prepare-release.outputs.has_changes == 'true'
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.prepare-release.outputs.version }}
      WINDOWS_PACKAGE: YAEP-v${{ needs.prepare-release.outputs.version }}-win-x64.zip
      LINUX_PACKAGE: YAEP-v${{ needs.prepare-release.outputs.version }}-linux-x64.tar.gz
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: package-*
          path: ./artifacts
          merge-multiple: false

      - name: Generate release notes
        id: generate_release_notes
        uses: actions/github-script@v7
        env:
          LAST_TAG: ${{ needs.prepare-release.outputs.last_tag }}
          VERSION: ${{ env.VERSION }}
        with:
          script: |
            const fs = require('fs');
            const lastTag = process.env.LAST_TAG;
            const version = process.env.VERSION;
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${version}`,
            };
            
            if (lastTag && lastTag.trim() !== '') {
              params.previous_tag_name = lastTag;
            }
            
            const { data: releaseNotes } = await github.rest.repos.generateReleaseNotes(params);
            core.setOutput('body', releaseNotes.body);
            fs.writeFileSync('CHANGELOG.md', releaseNotes.body);

      - name: Scan Windows package with VirusTotal
        id: virustotal_scan_windows
        continue-on-error: true
        env:
          VT_API_KEY: ${{ secrets.VT_API_KEY }}
        run: |
          $zipFile = "artifacts\${{ env.WINDOWS_PACKAGE }}"
          $apiKey = $env:VT_API_KEY
          $maxDirectUpload = 32 * 1024 * 1024
          $maxAttempts = 30
          
          if ([string]::IsNullOrWhiteSpace($apiKey)) {
            Write-Host "VT_API_KEY secret not set, skipping VirusTotal scan"
            echo "scan_url=" >> $env:GITHUB_OUTPUT
            echo "scan_id=" >> $env:GITHUB_OUTPUT
            exit 0
          }
          
          Write-Host "Uploading $zipFile to VirusTotal..."
          
          # Upload file (direct or via upload URL for large files)
          $fileSize = (Get-Item $zipFile).Length
          if ($fileSize -le $maxDirectUpload) {
            $response = curl.exe -s -X POST "https://www.virustotal.com/api/v3/files" `
              -H "x-apikey: $apiKey" `
              -F "file=@$zipFile"
          } else {
            Write-Host "File is larger than 32 MB, requesting upload URL..."
            $uploadUrlResponse = curl.exe -s -X GET "https://www.virustotal.com/api/v3/files/upload_url" `
              -H "x-apikey: $apiKey"
            $uploadUrl = ($uploadUrlResponse | ConvertFrom-Json).data
            Write-Host "Upload URL obtained, uploading file..."
            $response = curl.exe -s -X POST "$uploadUrl" `
              -H "x-apikey: $apiKey" `
              -F "file=@$zipFile"
          }
          
          $jsonResponse = $response | ConvertFrom-Json
          $analysisId = $jsonResponse.data.id
          Write-Host "File uploaded. Analysis ID: $analysisId"
          
          # Wait for analysis to complete (poll every 10 seconds, max 5 minutes)
          $attempt = 0
          $analysisComplete = $false
          
          function Get-FileHash {
            param($analysisData)
            $hash = $null
            $sources = @(
              { $analysisData.meta.file_info.sha256 },
              { if ($analysisData.data.links.item -match '/files/([a-f0-9]{64})$') { $matches[1] } },
              { $analysisData.data.relationships.file.data.id },
              { $analysisData.data.attributes.sha256 }
            )
            foreach ($source in $sources) {
              $hash = & $source
              if (-not [string]::IsNullOrWhiteSpace($hash)) { break }
            }
            return $hash
          }
          
          while ($attempt -lt $maxAttempts -and -not $analysisComplete) {
            Start-Sleep -Seconds 10
            $attempt++
            Write-Host "Checking analysis status (attempt $attempt/$maxAttempts)..."
            
            $analysisResponse = curl.exe -s -X GET "https://www.virustotal.com/api/v3/analyses/$analysisId" `
              -H "x-apikey: $apiKey"
            $analysisData = $analysisResponse | ConvertFrom-Json
            
            if ($analysisData.data.attributes.status -eq "completed") {
              $analysisComplete = $true
              $stats = $analysisData.data.attributes.stats
              $harmless = $stats.harmless
              $malicious = $stats.malicious
              $suspicious = $stats.suspicious
              $undetected = $stats.undetected
              $total = $harmless + $malicious + $suspicious + $undetected
              
              $fileHash = Get-FileHash $analysisData
              if ([string]::IsNullOrWhiteSpace($fileHash)) {
                Write-Host "Warning: Could not extract file hash from analysis response"
                $fileHash = "unknown"
              }
              
              $permalink = "https://www.virustotal.com/gui/file/$fileHash"
              
              # Determine verdict
              if ($malicious -gt 0) {
                $verdict = "$malicious/$total engines detected threats"
              } elseif ($suspicious -gt 0) {
                $verdict = "$suspicious/$total engines flagged as suspicious"
              } else {
                $verdict = "Clean ($harmless/$total engines found no threats)"
              }
              
              Write-Host "Analysis complete!"
              Write-Host "File Hash: $fileHash"
              Write-Host "Verdict: $verdict"
              Write-Host "Permalink: $permalink"
              
              echo "scan_url=$permalink" >> $env:GITHUB_OUTPUT
              echo "file_hash=$fileHash" >> $env:GITHUB_OUTPUT
              echo "scan_id=$analysisId" >> $env:GITHUB_OUTPUT
              echo "verdict=$verdict" >> $env:GITHUB_OUTPUT
              echo "stats=Harmless: $harmless, Malicious: $malicious, Suspicious: $suspicious, Undetected: $undetected" >> $env:GITHUB_OUTPUT
            }
          }
          
          if (-not $analysisComplete) {
            Write-Host "Analysis did not complete within timeout period"
            echo "scan_url=" >> $env:GITHUB_OUTPUT
            echo "scan_id=$analysisId" >> $env:GITHUB_OUTPUT
          }

      - name: Update release notes with VirusTotal scan
        if: steps.virustotal_scan_windows.outcome == 'success' && steps.virustotal_scan_windows.outputs.scan_url
        run: |
          $vtLink = "${{ steps.virustotal_scan_windows.outputs.scan_url }}"
          $vtFileHash = "${{ steps.virustotal_scan_windows.outputs.file_hash }}"
          $vtVerdict = "${{ steps.virustotal_scan_windows.outputs.verdict }}"
          $vtStats = "${{ steps.virustotal_scan_windows.outputs.stats }}"
          
          if ([string]::IsNullOrWhiteSpace($vtLink) -or $vtLink -eq "https://www.virustotal.com/gui/file/") {
            Write-Host "No valid VirusTotal scan URL available, skipping update"
            exit 0
          }
          
          $changelog = Get-Content CHANGELOG.md -Raw
          $fileHashInfo = ""
          if (-not [string]::IsNullOrWhiteSpace($vtFileHash) -and $vtFileHash -ne "unknown") {
            $fileHashInfo = "`n- **File Hash (SHA256)**: $vtFileHash"
          }
          $vtSection = "`n`n## Security Scan (Windows)`n`nThis release has been scanned with VirusTotal for your safety.`n`n- **Scan Result**: $vtVerdict`n- **Statistics**: $vtStats$fileHashInfo`n`n[View full scan report]($vtLink)"
          
          $updatedChangelog = $changelog + $vtSection
          Set-Content CHANGELOG.md -Value $updatedChangelog -NoNewline

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.VERSION }}
          name: Release v${{ env.VERSION }}
          body_path: CHANGELOG.md
          files: |
            artifacts/${{ env.WINDOWS_PACKAGE }}
            artifacts/${{ env.LINUX_PACKAGE }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

