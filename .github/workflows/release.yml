name: Build and Release

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'

env:
  DOTNET_VERSION: '9.0.x'

jobs:
  build-and-release:
    runs-on: windows-latest
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, 'build-and-release')
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore YAEP.WPF.sln

      - name: Build solution
        run: dotnet build YAEP.WPF.sln --configuration Release --no-restore

      - name: Get current version
        id: get_version
        run: |
          $version = Select-String -Path "YAEP.WPF\YAEP.WPF.csproj" -Pattern '<Version>(\d+)\.(\d+)\.(\d+)</Version>' | ForEach-Object { $_.Matches.Groups[1..3].Value -join '.' }
          if ([string]::IsNullOrEmpty($version)) {
            $version = "1.0.0"
          }
          Write-Host "Current version: $version"
          echo "CURRENT_VERSION=$version" >> $env:GITHUB_ENV
          $parts = $version -split '\.'
          echo "MAJOR=$($parts[0])" >> $env:GITHUB_ENV
          echo "MINOR=$($parts[1])" >> $env:GITHUB_ENV
          echo "PATCH=$($parts[2])" >> $env:GITHUB_ENV

      - name: Get last tag
        id: get_last_tag
        run: |
          $ErrorActionPreference = "Continue"
          $lastTag = ""
          $hasChanges = "false"
          
          # Fetch all tags to ensure we have them
          Write-Host "Fetching all tags..."
          git fetch --tags --force
          
          # Get the most recent tag (sorted by version), won't fail if no tags exist
          $tagOutput = git tag --sort=-version:refname | Select-Object -First 1
          if (-not [string]::IsNullOrWhiteSpace($tagOutput)) {
            $lastTag = $tagOutput.Trim()
            Write-Host "Found last tag: $lastTag"
            
            # Get the commit SHA that the tag points to (handles both annotated and lightweight tags)
            $tagCommit = git rev-parse "$lastTag^{commit}" 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host "Warning: Could not resolve tag commit: $tagCommit"
              Write-Host "Assuming changes exist for safety"
              $hasChanges = "true"
            } else {
              $tagCommit = $tagCommit.Trim()
              Write-Host "Tag $lastTag points to commit: $tagCommit"
              
              # Get current HEAD commit
              $headCommit = git rev-parse HEAD 2>&1
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Warning: Could not get HEAD commit"
                Write-Host "Assuming changes exist for safety"
                $hasChanges = "true"
              } else {
                $headCommit = $headCommit.Trim()
                Write-Host "Current HEAD commit: $headCommit"
                
                # Check if there are commits between tag and HEAD
                # Use ^{commit} to dereference annotated tags to their commit
                Write-Host "Checking for commits between $lastTag and HEAD..."
                $commitCountOutput = git rev-list "$lastTag^{commit}..HEAD" --count 2>&1
                
                if ($LASTEXITCODE -eq 0) {
                  if (-not [string]::IsNullOrWhiteSpace($commitCountOutput)) {
                    $commitCount = [int]$commitCountOutput.Trim()
                    Write-Host "Commit count: $commitCount"
                    if ($commitCount -gt 0) {
                      $hasChanges = "true"
                      Write-Host "Found $commitCount new commits since last tag"
                    } else {
                      Write-Host "No new commits since last tag, skipping version bump and release"
                    }
                  } else {
                    Write-Host "No commit count output, checking if commits exist..."
                    # Fallback: check if there are any commits at all
                    $commitList = git rev-list "$lastTag^{commit}..HEAD" 2>&1
                    if (-not [string]::IsNullOrWhiteSpace($commitList)) {
                      $hasChanges = "true"
                      Write-Host "Found commits between tag and HEAD"
                    } else {
                      Write-Host "No new commits since last tag, skipping version bump and release"
                    }
                  }
                } else {
                  Write-Host "Warning: git rev-list failed with exit code $LASTEXITCODE"
                  Write-Host "Output: $commitCountOutput"
                  Write-Host "Assuming changes exist for safety"
                  $hasChanges = "true"
                }
              }
            }
          } else {
            Write-Host "No existing tags found - this will be the first release"
            $hasChanges = "true"
          }
          
          Write-Host "Last tag: $lastTag (empty if none)"
          Write-Host "Has changes: $hasChanges"
          echo "has_changes=$hasChanges" >> $env:GITHUB_OUTPUT
          echo "LAST_TAG=$lastTag" >> $env:GITHUB_ENV

      - name: Increment version
        id: increment_version
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $patch = [int]$env:PATCH + 1
          $newVersion = "$env:MAJOR.$env:MINOR.$patch"
          Write-Host "New version: $newVersion"
          echo "version=$newVersion" >> $env:GITHUB_OUTPUT

      - name: Update version in project files
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $newVersion = "${{ steps.increment_version.outputs.version }}"
          $files = @("YAEP.WPF\YAEP.WPF.csproj", "YAEP.Interop\YAEP.Interop.csproj")
          foreach ($file in $files) {
            (Get-Content $file) -replace '<Version>(\d+\.\d+\.\d+)</Version>', "<Version>$newVersion</Version>" | Set-Content $file
            (Get-Content $file) -replace '<AssemblyVersion>(\d+\.\d+\.\d+\.\d+)</AssemblyVersion>', "<AssemblyVersion>$newVersion.0</AssemblyVersion>" | Set-Content $file
            (Get-Content $file) -replace '<FileVersion>(\d+\.\d+\.\d+\.\d+)</FileVersion>', "<FileVersion>$newVersion.0</FileVersion>" | Set-Content $file
          }

      - name: Rebuild with new version
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          dotnet build YAEP.WPF.sln --configuration Release --no-restore

      - name: Publish application
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          dotnet publish YAEP.WPF/YAEP.WPF.csproj --configuration Release --output ./publish --no-build

      - name: Configure Git
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version bump
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git add YAEP.WPF/YAEP.WPF.csproj YAEP.Interop/YAEP.Interop.csproj
          git commit -m "Bump version to ${{ steps.increment_version.outputs.version }}" || exit 0

      - name: Generate changelog
        id: generate_changelog
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $newVersion = "${{ steps.increment_version.outputs.version }}"
          $lastTag = $env:LAST_TAG
          $repo = "${{ github.repository }}"
          $repoUrl = "https://github.com/$repo"
          $changelog = "# Release $newVersion`n`n"
          
          if ([string]::IsNullOrEmpty($lastTag)) {
            $changelog += "## Initial Release`n`n"
            $commitLines = git log --pretty=format:"%H|%h|%s" --no-merges
          } else {
            $changelog += "## Changes since $lastTag`n`n"
            $commitLines = git log $lastTag..HEAD --pretty=format:"%H|%h|%s" --no-merges
          }
          
          if ([string]::IsNullOrEmpty($commitLines)) {
            $changelog += "- No changes detected`n"
          } else {
            $changelog += "## Commits`n`n"
            foreach ($line in $commitLines) {
              if (-not [string]::IsNullOrWhiteSpace($line)) {
                $parts = $line -split '\|', 3
                $fullHash = $parts[0]
                $shortHash = $parts[1]
                $message = $parts[2]
                $commitUrl = "$repoUrl/commit/$fullHash"
                $changelog += "- $message ([$shortHash]($commitUrl))`n"
              }
            }
            $changelog += "`n"
          }
          
          # Get merged pull requests using GitHub API
          $changelog += "`n## Pull Requests`n`n"
          $repo = "${{ github.repository }}"
          $token = "${{ secrets.GITHUB_TOKEN }}"
          
          try {
            $tagDate = $null
            if (-not [string]::IsNullOrEmpty($lastTag)) {
              $tagDate = git log -1 --format=%ai $lastTag
            }
            
            $url = "https://api.github.com/repos/$repo/pulls?state=closed&per_page=50&sort=updated"
            $headers = @{
              "Authorization" = "Bearer $token"
              "Accept" = "application/vnd.github.v3+json"
            }
            
            $response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
            $mergedPRs = $response | Where-Object { $_.merged_at -ne $null }
            
            if ($mergedPRs.Count -eq 0) {
              $changelog += "- No merged pull requests found`n"
            } else {
              foreach ($pr in $mergedPRs) {
                $shouldInclude = $false
                if ([string]::IsNullOrEmpty($lastTag)) {
                  $shouldInclude = $true
                } else {
                  $prMergedDate = [DateTime]::Parse($pr.merged_at)
                  $tagDateParsed = [DateTime]::Parse($tagDate)
                  if ($prMergedDate -gt $tagDateParsed) {
                    $shouldInclude = $true
                  }
                }
                
                if ($shouldInclude) {
                  $prNumber = $pr.number
                  $prTitle = $pr.title
                  $prAuthor = $pr.user.login
                  $prUrl = "$repoUrl/pull/$prNumber"
                  $mergedDate = [DateTime]::Parse($pr.merged_at).ToString("yyyy-MM-dd")
                  $changelog += "- $prTitle ([#$prNumber]($prUrl)) by @$prAuthor (merged: $mergedDate)`n"
                }
              }
            }
          } catch {
            Write-Host "Warning: Could not fetch pull requests: $_"
            $changelog += "- Unable to fetch pull requests`n"
          }
          
          $changelog | Out-File -FilePath "CHANGELOG.md" -Encoding utf8
          Write-Host "Changelog generated"

      - name: Create git tag
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $version = "${{ steps.increment_version.outputs.version }}"
          git tag -a "v$version" -m "Release v$version"
          git push origin "v$version"

      - name: Push version bump commit
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          git push origin main

      - name: Create release package
        id: create_package
        if: steps.get_last_tag.outputs.has_changes == 'true'
        run: |
          $version = "${{ steps.increment_version.outputs.version }}"
          $zipName = "YAEP-v$version.zip"
          Compress-Archive -Path ./publish/* -DestinationPath $zipName -Force
          Write-Host "Created package: $zipName"
          echo "package_name=$zipName" >> $env:GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.get_last_tag.outputs.has_changes == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.increment_version.outputs.version }}
          name: Release v${{ steps.increment_version.outputs.version }}
          body_path: CHANGELOG.md
          files: YAEP-v${{ steps.increment_version.outputs.version }}.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

